"""
test_golden_snapshot.py — Regression detection against the golden manifest.
============================================================================
Compares current artifacts against the last-known-good golden manifest.
Catches: row count regressions, schema changes (new/dropped columns, dtype drift),
sample data drift, and new/missing artifacts.

The golden manifest is generated by:
    python3 scripts/generate_golden_manifest.py

Markers:
    @pytest.mark.golden — run with: pytest -m golden
"""
from __future__ import annotations

import json
import pathlib
import warnings

import pandas as pd
import pytest

ROOT = pathlib.Path(__file__).resolve().parent.parent
TABLES = ROOT / "artifacts" / "tables"
MANIFEST_PATH = ROOT / "artifacts" / "metrics" / "golden_manifest.json"

# Row count regression tolerance — allow up to 5% drop before failing
ROW_DROP_TOLERANCE = 0.05

# These artifacts are expected stubs (0 rows OK)
KNOWN_STUBS = {
    "employer_scores", "oews_wages", "visa_bulletin",
    "fact_trac_adjudications", "fact_acs_wages",
}


def _load_manifest() -> dict:
    if not MANIFEST_PATH.exists():
        pytest.skip("Golden manifest not found — run: python3 scripts/generate_golden_manifest.py")
    with open(MANIFEST_PATH) as f:
        return json.load(f)


def _load_artifact(name: str) -> pd.DataFrame | None:
    flat = TABLES / f"{name}.parquet"
    partitioned = TABLES / name
    if flat.is_file():
        return pd.read_parquet(flat)
    elif partitioned.is_dir():
        parts = sorted(partitioned.glob("**/*.parquet"))
        if not parts:
            return None
        frames = []
        for p in parts:
            try:
                frames.append(pd.read_parquet(p))
            except Exception:
                continue
        return pd.concat(frames, ignore_index=True) if frames else None
    return None


@pytest.fixture(scope="module")
def manifest():
    return _load_manifest()


@pytest.fixture(scope="module")
def artifact_entries(manifest):
    return manifest.get("artifacts", {})


# ── Test: No artifacts went missing ─────────────────────────────────────────

class TestNoRegressions:
    """Ensure no previously-OK artifact has disappeared."""

    def test_no_artifacts_lost(self, artifact_entries):
        """Every artifact that was 'ok' in the manifest should still exist."""
        lost = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok":
                continue
            if name in KNOWN_STUBS:
                continue
            df = _load_artifact(name)
            if df is None:
                lost.append(name)
        assert not lost, f"Artifacts disappeared since last golden snapshot: {lost}"


# ── Test: Row count regressions ─────────────────────────────────────────────

class TestRowCounts:
    """Detect unexpected row count drops (tolerance: {ROW_DROP_TOLERANCE:.0%})."""

    def test_no_row_count_regression(self, artifact_entries):
        """Row counts should not drop by more than 5% from golden baseline."""
        failures = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok" or name in KNOWN_STUBS:
                continue
            golden_rows = entry["rows"]
            if golden_rows == 0:
                continue

            df = _load_artifact(name)
            if df is None:
                continue

            current_rows = len(df)
            drop_pct = (golden_rows - current_rows) / golden_rows

            if drop_pct > ROW_DROP_TOLERANCE:
                failures.append(
                    f"{name}: golden={golden_rows:,} → current={current_rows:,} "
                    f"(dropped {drop_pct:.1%})"
                )

        assert not failures, (
            f"Row count regressions detected:\n" + "\n".join(f"  • {f}" for f in failures)
        )

    def test_row_counts_increased_only_warns(self, artifact_entries):
        """Row count increases are OK but worth noting (new data added)."""
        increases = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok" or name in KNOWN_STUBS:
                continue
            golden_rows = entry["rows"]
            if golden_rows == 0:
                continue

            df = _load_artifact(name)
            if df is None:
                continue

            current_rows = len(df)
            if current_rows > golden_rows * 1.10:
                increases.append(
                    f"{name}: golden={golden_rows:,} → current={current_rows:,} "
                    f"(+{(current_rows - golden_rows) / golden_rows:.1%})"
                )

        if increases:
            warnings.warn(
                f"Row count increases >10%:\n" + "\n".join(f"  • {i}" for i in increases)
            )


# ── Test: Schema stability ──────────────────────────────────────────────────

class TestSchemaStability:
    """Detect column additions, removals, and dtype changes."""

    def test_no_columns_dropped(self, artifact_entries):
        """No columns should disappear from existing artifacts."""
        dropped = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok" or name in KNOWN_STUBS:
                continue
            golden_cols = set(entry.get("columns", []))
            if not golden_cols:
                continue

            df = _load_artifact(name)
            if df is None:
                continue

            current_cols = set(df.columns.tolist())
            missing = golden_cols - current_cols
            if missing:
                dropped.append(f"{name}: lost columns {sorted(missing)}")

        assert not dropped, (
            f"Columns dropped from artifacts:\n" + "\n".join(f"  • {d}" for d in dropped)
        )

    def test_dtype_signature_stable(self, artifact_entries):
        """dtype signatures should not change (int64→object, etc.)."""
        changes = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok" or name in KNOWN_STUBS:
                continue
            golden_sig = entry.get("dtype_signature", "")
            if not golden_sig:
                continue

            df = _load_artifact(name)
            if df is None:
                continue

            # Build current signature same way as manifest generator
            current_pairs = sorted(f"{c}:{df[c].dtype}" for c in df.columns)
            current_sig = "|".join(current_pairs)

            if current_sig != golden_sig:
                changes.append(f"{name}: dtype signature changed")

        if changes:
            warnings.warn(
                f"dtype changes detected (may be benign):\n"
                + "\n".join(f"  • {c}" for c in changes)
            )

    def test_new_columns_only_warns(self, artifact_entries):
        """New columns are OK (additive change) but worth noting."""
        additions = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok" or name in KNOWN_STUBS:
                continue
            golden_cols = set(entry.get("columns", []))
            if not golden_cols:
                continue

            df = _load_artifact(name)
            if df is None:
                continue

            current_cols = set(df.columns.tolist())
            new_cols = current_cols - golden_cols
            if new_cols:
                additions.append(f"{name}: new columns {sorted(new_cols)}")

        if additions:
            warnings.warn(
                f"New columns added:\n" + "\n".join(f"  • {a}" for a in additions)
            )


# ── Test: Numeric range stability ───────────────────────────────────────────

class TestNumericRanges:
    """Detect extreme shifts in numeric column bounds."""

    def test_no_extreme_range_shift(self, artifact_entries):
        """Numeric min/max should not shift dramatically (catches unit errors)."""
        issues = []
        for name, entry in artifact_entries.items():
            if entry.get("status") != "ok" or name in KNOWN_STUBS:
                continue
            golden_bounds = entry.get("numeric_bounds", {})
            if not golden_bounds:
                continue

            df = _load_artifact(name)
            if df is None:
                continue

            for col, gb in golden_bounds.items():
                if col not in df.columns:
                    continue
                series = df[col].dropna()
                if len(series) == 0:
                    continue

                cur_min, cur_max = float(series.min()), float(series.max())
                g_min, g_max = gb["min"], gb["max"]

                # Flag if current max is >10x golden max (or min went hugely negative)
                if g_max > 0 and cur_max > g_max * 10:
                    issues.append(
                        f"{name}.{col}: max {g_max:,.2f} → {cur_max:,.2f} (>10x increase)"
                    )
                if g_min >= 0 and cur_min < -abs(g_max) * 0.1:
                    issues.append(
                        f"{name}.{col}: min went negative {cur_min:,.2f} (golden min={g_min:,.2f})"
                    )

        assert not issues, (
            f"Extreme numeric range shifts:\n" + "\n".join(f"  • {i}" for i in issues)
        )
